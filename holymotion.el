;;; holymotion.el --- evil-easymotion, purified of evil

;; Author: Overdr0ne <scmorris.dev@gmail.com>
;; Keywords: convenience
;; Version: 20230210
;; Package-Requires: ((emacs "24") (avy "0.3.0") (cl-lib "0.5"))

;;; License:

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This code was shamelessly forked from https://github.com/PythonNut/evil-easymotion
;; which was itself a clone of the popular holymotion package for vim, which
;; describes itself in these terms:

;; > EasyMotion provides a much simpler way to use some motions in vim.
;; > It takes the <number> out of <number>w or <number>f{char} by
;; > highlighting all possible choices and allowing you to press one key
;; > to jump directly to the target.

;; If you're having trouble picturing this, please visit the github repo
;; for a screencast.

;; Usage/status
;; ============

;; A handful of motions are provided, prefixed with `holymotion`
;; It's easy to define your own holymotions:
;; (holymotion-make-motion
;;  holymotion-forward-to-word #'forward-to-word
;;  :scope 'line)
;;;; More advanced use-cases are detailed in README.md.

;;; Code:
(require 'cl-lib)
(require 'avy)

(defgroup holymotion nil
  "Emulate vim-easymotion."
  :group 'convenience
  :prefix "holymotion-")

(defcustom holymotion-keys nil
  "Value of `avy-keys' to set during motions.  Set to nil to leave unchanged."
  :type '(repeat :tag "Keys" character))

(defcustom holymotion-style nil
  "Value of `avy-style' to set during motions.  Set to nil to leave unchanged."
  :type '(choice
          (const :tag "Pre" pre)
          (const :tag "At" at)
          (const :tag "At Full" at-full)
          (const :tag "Post" post)
          (const :tag "De Bruijn" de-bruijn)
          (const :tag "Default" nil)))

(defvar holymotion-map (make-sparse-keymap)
  "Map your holymotions here and bind this map to a prefix key.")

(defvar holymotion-mode-map (make-sparse-keymap)
  "Map your holymotions here and enable them with `holymotion-mode'.")
(define-minor-mode holymotion-mode
  "A minor mode to transiently enable `holymotion-mode-map' bindings."
  :keymap holymotion-mode-map)

(defun holymotion--jump (points)
  "Avy-jump to the set of POINTS generated by collector."
  (require 'avy)
  (let* ((avy-style (or holymotion-style avy-style))
         (avy-keys (or holymotion-keys avy-keys)))
    (avy-process points
                 (avy--style-fn avy-style))))

(defun holymotion--default-collect-postprocess (points)
  "Collect default postprocess using jump POINTS."
  (cl-stable-sort
   points
   #'<
   :key (lambda (pt)
          (if (equal (selected-window) (cdr pt))
              (abs (- (point) (car pt)))
            most-positive-fixnum))))

;;;###autoload
(defun holymotion--collect (func &optional
                                 scope
                                 all-windows
                                 initial-motion
                                 collect-postprocess
                                 include-invisible)
  "Repeatedly execute FUNC and collect the cursor positions.

Optionally:

SCOPE: An object to limit the scope of an holymotion.  'object' may be any
*thing* understood by `thing-at-point'.  In practice, 'object' will often be
'line'.

ALL-WINDOWS to consider in search of candidates.

INITIAL-MOTION: When specified, (goto-char (funcall callable)) is run before
the motion is executed.  For example, use this to jump to the BOL of each line
as in holymotion with :initial-position #'point-at-bol.  Unlike in
:pre-hook, callable is run once per window when :all-windows is specified.

COLLECT-POSTPROCESS: When specified, callable is called on the collected list
of points (which is of the form ((point window)...)).  Otherwise, the default
function, which sorts the points in order of increasing distance from `(point)',
is used.

INCLUDE-INVISIBLE: When 'expr' is non-nil, the motion will not skip over
invisible overlays.  This may be required for motions that generate dramatically
different sets of points if they are started at different locations.  This
defaults to nil."
  (cl-letf ((points nil)
            (point nil)
            (avy-all-windows all-windows)
            ;; make sure the motion doesn't move the window
            (scroll-conservatively 101)
            (smooth-scrolling-mode nil)
            (scroll-margin 0))
    (if (functionp func)
        (avy-dowindows current-prefix-arg
          (save-excursion
            (save-restriction
              (when initial-motion
                (goto-char (funcall initial-motion)))
              (cl-destructuring-bind (beg . end)
                  (if scope
                      (bounds-of-thing-at-point scope)
                    (cons (point-min)
                          (point-max)))

                ;; trim trailing newline
                (when (= (char-before end) 10)
                  (cl-decf end))

                (narrow-to-region (max beg (window-start))
                                  (min end (window-end))))
              (while (and (ignore-errors
                            (setq this-command func
                                  last-command func)
                            (call-interactively func)
                            (unless include-invisible
                              (let ((ov (car (overlays-at (point)))))
                                (while (and ov (member
                                                'invisible
                                                (overlay-properties ov)))
                                  (goto-char (overlay-end ov))
                                  ;; This is a bit of a hack, since we
                                  ;; can't guarantee that we will end
                                  ;; up at the same point if we start
                                  ;; at the end of the invisible
                                  ;; region vs. looping through it.
                                  (call-interactively func)
                                  (setq ov (car (overlays-at (point)))))))
                            t)
                          (setq point (cons (point) (get-buffer-window)))
                          (not (member point points))
                          (push point points))))))
      (setq points (cl-remove-duplicates
                    (cl-mapcan (lambda (f)
                                 (holymotion--collect f scope all-windows))
                               func))))
    (funcall (or collect-postprocess
                 #'holymotion--default-collect-postprocess)
             points)))

(cl-defmacro holymotion-make-motion (name
                                     funcs
                                     &key
                                     pre-hook
                                     post-hook
                                     bind
                                     scope
                                     all-windows
                                     initial-motion
                                     collect-postprocess
                                     include-invisible)
  "Automatically define an holymotion for FUNCS, naming it NAME.

Keywords:

Add PRE-HOOK or POST-HOOK to further customize your motion command.

BIND: A list of forms to bind around the entire holymotion.  'forms' may be any
bindings accepted by `cl-letf'.

SCOPE: An ’object’ to limit the scope of an holymotion.  'object' may be any
*thing* understood by `thing-at-point'.  In practice, 'object' will often be
'line'.

INITIAL-MOTION: When specified, (goto-char (funcall callable)) is run before
the motion is executed.  For example, use this to jump to the BOL of each line
as in holymotion with :initial-position #'point-at-bol.  Unlike in
:pre-hook, 'callable' is run once per window when :all-windows is specified.

COLLECT-POSTPROCESS: When specified, 'callable' is called on the collected list
of points (which is of the form ((point window)...)).  Otherwise, the default
function, which sorts the points in order of increasing distance from (point),
is used.

INCLUDE-INVISIBLE: When 'expr' is non-nil, the motion will not skip over
invisible overlays.  This may be required for motions that generate dramatically
different sets of points if they are started at different locations.  This
defaults to nil."
  `(defun ,name ()
     (interactive)
     (require 'avy)
     (avy-with ,name
       (cl-letf* ,bind
         ,(when pre-hook `(funcall ,(if (functionp pre-hook)
                                        pre-hook
                                      `(lambda () ,pre-hook))))
         (holymotion--jump (holymotion--collect ,funcs
                                                ,scope
                                                ,all-windows
                                                ,initial-motion
                                                ,collect-postprocess
                                                ,include-invisible))
         ,(when post-hook `(funcall ,(if (functionp post-hook)
                                         post-hook
                                       `(lambda () ,post-hook))))))))

(defmacro holymotion-derive-cmd (cmd)
  "Create and name a holymotion from CMD."
  `(progn
     (holymotion-make-motion ,(intern (concat "holymotion-" (symbol-name cmd)))
                             #',cmd
                             :scope 'line)))

(provide 'holymotion)
;;; holymotion.el ends here
