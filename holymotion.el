;;; holymotion.el --- A port of vim's easymotion to emacs

;; Copyright (C) 2014, 2015, 2016, 2018 PythonNut
;; Copyright (C) 2017 wouter bolsterlee

;; Author: PythonNut <pythonnut@pythonnut.com>
;; Keywords: convenience, evil
;; Version: 20160228
;; URL: https://github.com/pythonnut/holymotion
;; Package-Requires: ((emacs "24") (avy "0.3.0") (cl-lib "0.5"))

;;; License:

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This is a clone of the popular easymotion package for vim, which
;; describes itself in these terms:

;; > EasyMotion provides a much simpler way to use some motions in vim.
;; > It takes the <number> out of <number>w or <number>f{char} by
;; > highlighting all possible choices and allowing you to press one key
;; > to jump directly to the target.

;; If you're having trouble picturing this, please visit the github repo
;; for a screencast.

;; Usage/status
;; ============

;; holymotion, rather unsurprisingly can use evil. However, you don't
;; _need_ evil to use it. holymotion can happily define motions for
;; regular emacs commands. With that said, evil is recommended, not
;; least because it's awesome.

;; Currently most motions are supported, and it's easy to define your own easymotions.

;;   (holymotion-define (kbd "SPC w") 'evil-forward-word-begin)

;; To define easymotions for all motions that evil defines by default, add

;;   (holymotion-default-keybindings "SPC")

;; This binds all motions under the prefix `SPC` in `evil-motion-state-map`. This is not done by default for motions defined manually. You will need to supply the prefix.

;; More advanced use-cases are detailed in the github README.

;;; Code:
(require 'cl-lib)

(eval-when-compile
  (require 'avy)
  (require 'evil))

(defgroup holymotion nil
  "Emulate vim-easymotion"
  :group 'convenience
  :prefix "holymotion-")

(defcustom holymotion-keys nil
  "Value of `avy-keys' to set during motions. Set to nil to leave unchanged."
  :type '(repeat :tag "Keys" character))

(defcustom holymotion-style nil
  "Value of `avy-style' to set during motions. Set to nil to leave unchanged."
  :type '(choice
          (const :tag "Pre" pre)
          (const :tag "At" at)
          (const :tag "At Full" at-full)
          (const :tag "Post" post)
          (const :tag "De Bruijn" de-bruijn)
          (const :tag "Default" nil)))

(defvar holymotion-map (make-sparse-keymap)
  "Keymap used for the default bindings")

;; macro helper, from evil source
(eval-and-compile
  (defun holymotion--unquote (exp)
    "Return EXP unquoted."
    (while (member (car-safe exp) '(quote function))
      (setq exp (cadr exp)))
    exp)

  (defun holymotion--make-name (func)
    (format "holymotion--motion-%s"
            (if (functionp func)
                (symbol-name (holymotion--unquote func))
              (mapconcat (lambda (f)
                           (symbol-name (holymotion--unquote f)))
                         func
                         "-")))))

(defun holymotion--jump (points)
  "avy-jump to the set of points generated by collector"
  (require 'avy)
  (let* ((avy-style (or holymotion-style avy-style))
         (avy-keys (or holymotion-keys avy-keys)))
    (avy--process points
                  (avy--style-fn avy-style))))

(defun holymotion--default-collect-postprocess (points)
  (cl-stable-sort
   points
   #'<
   :key (lambda (pt)
          (if (equal (selected-window) (cdr pt))
              (abs (- (point) (car pt)))
            most-positive-fixnum))))

;;;###autoload
(defun holymotion--collect (func &optional
                             scope
                             all-windows
                             initial-point
                             sort-key
                             collect-postprocess
                             include-invisible)
  "Repeatedly execute func, and collect the cursor positions into a list"
  (cl-letf ((points nil)
            (point nil)
            (avy-all-windows all-windows)
            ;; make sure the motion doesn't move the window
            (scroll-conservatively 101)
            (smooth-scrolling-mode nil)
            (scroll-margin 0))
    (if (functionp func)
        (avy-dowindows current-prefix-arg
          (save-excursion
            (save-restriction
              (when initial-point
                (goto-char (funcall initial-point)))
              (cl-destructuring-bind (beg . end)
                  (if scope
                      (bounds-of-thing-at-point scope)
                    (cons (point-min)
                          (point-max)))

                ;; trim trailing newline
                (when (= (char-before end) 10)
                  (cl-decf end))

                (narrow-to-region (max beg (window-start))
                                  (min end (window-end))))
              (while (and (ignore-errors
                            (setq this-command func
                                  last-command func)
                            (call-interactively func)
                            (unless include-invisible
                              (let ((ov (car (overlays-at (point)))))
                                (while (and ov (member
                                                'invisible
                                                (overlay-properties ov)))
                                  (goto-char (overlay-end ov))
                                  ;; This is a bit of a hack, since we
                                  ;; can't guarantee that we will end
                                  ;; up at the same point if we start
                                  ;; at the end of the invisible
                                  ;; region vs. looping through it.
                                  (call-interactively func)
                                  (setq ov (car (overlays-at (point)))))))
                            t)
                          (setq point (cons (point) (get-buffer-window)))
                          (not (member point points))
                          (push point points))))))
      (setq points (cl-remove-duplicates
                    (cl-mapcan (lambda (f)
                                 (holymotion--collect f scope all-windows))
                               func))))
    (funcall (or collect-postprocess
                 #'holymotion--default-collect-postprocess)
             points)))

(eval-and-compile
  (defun holymotion--compute-inclusivity (funcs)
    (when (and (= (length funcs) 1)
               (evil-has-command-properties-p (car funcs)))
      `(setq evil-this-type
             ',(evil-get-command-property (car funcs) :type)))))

(cl-defmacro holymotion-make-motion (name
                                 funcs
                                 &key
                                 pre-hook
                                 post-hook
                                 bind
                                 scope
                                 all-windows
                                 initial-point
                                 push-jump
                                 collect-postprocess
                                 include-invisible)
  "Automatically define an evil easymotion for `func', naming it `name'"
  `(,(if all-windows
         'evil-define-command
       'evil-define-motion)
    ,name (&optional _count)
    (require 'avy)
    (avy-with ,name
      (evil-without-repeat
        ,(holymotion--compute-inclusivity funcs)
        (cl-letf* ,bind
          ,(when (or push-jump (not scope))
             '(evil--jumps-push))
          ,(when pre-hook `(funcall ,(if (functionp pre-hook)
                                         pre-hook
                                       `(lambda () ,pre-hook))))
          (holymotion--jump (holymotion--collect ,funcs
                                         ,scope
                                         ,all-windows
                                         ,initial-point
                                         ,collect-postprocess
                                         ,include-invisible))
          ,(when post-hook `(funcall ,(if (functionp post-hook)
                                          post-hook
                                        `(lambda () ,post-hook)))))))))

(cl-defmacro holymotion-make-motion-plain (name
                                       funcs
                                       &key
                                       pre-hook
                                       post-hook
                                       bind
                                       scope
                                       all-windows
                                       initial-point
                                       collect-postprocess
                                       include-invisible)
  "Automatically define a plain easymotion for `func', naming it `name'"
  `(defun ,name ()
     (interactive)
     (require 'avy)
     (avy-with ,name
       (cl-letf* ,bind
         ,(when pre-hook `(funcall ,(if (functionp pre-hook)
                                        pre-hook
                                      `(lambda () ,pre-hook))))
         (holymotion--jump (holymotion--collect ,funcs
                                        ,scope
                                        ,all-windows
                                        ,initial-point
                                        ,collect-postprocess
                                        ,include-invisible))
         ,(when post-hook `(funcall ,(if (functionp post-hook)
                                         post-hook
                                       `(lambda () ,post-hook))))))))

(cl-defmacro holymotion-create (motions
                            &key
                            name
                            pre-hook
                            post-hook
                            bind
                            scope
                            all-windows
                            initial-point
                            push-jump
                            collect-postprocess
                            include-invisible)
  `(holymotion-make-motion
    ,(or (holymotion--unquote name)
         (intern (holymotion--make-name motions)))
    ,motions
    :pre-hook ,pre-hook
    :post-hook ,post-hook
    :bind ,bind
    :scope ,scope
    :all-windows ,all-windows
    :initial-point ,initial-point
    :push-jump ,push-jump
    :collect-postprocess ,collect-postprocess
    :include-invisible ,include-invisible))

(cl-defmacro holymotion-create-plain (motions
                                  &key
                                  name
                                  pre-hook
                                  post-hook
                                  bind
                                  scope
                                  all-windows
                                  initial-point
                                  collect-postprocess
                                  include-invisible)
  `(holymotion-make-motion-plain
    ,(or (holymotion--unquote name)
         (intern (holymotion--make-name motions)))
    ,motions
    :pre-hook ,pre-hook
    :post-hook ,post-hook
    :bind ,bind
    :scope ,scope
    :all-windows ,all-windows
    :initial-point ,initial-point
    :collect-postprocess ,collect-postprocess
    :include-invisible ,include-invisible))

(cl-defmacro holymotion-define (key
                            motions
                            &key
                            name
                            pre-hook
                            post-hook
                            bind
                            scope
                            all-windows
                            initial-point
                            push-jump
                            collect-postprocess
                            include-invisible)
  "Automatically create and bind an evil motion"
  `(define-key ,(if all-windows
                    'evil-normal-state-map
                  'evil-motion-state-map)
     ,key
     (holymotion-create ,motions
                    :name ,name
                    :pre-hook ,pre-hook
                    :post-hook ,post-hook
                    :bind ,bind
                    :scope ,scope
                    :all-windows ,all-windows
                    :initial-point ,initial-point
                    :push-jump ,push-jump
                    :collect-postprocess ,collect-postprocess
                    :include-invisible ,include-invisible)))

;;;###autoload (autoload 'holymotion-motion-forward-word-begin "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-forward-word-begin #'evil-forward-word-begin
 :scope 'line)

;;;###autoload (autoload 'holymotion-motion-forward-WORD-begin "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-forward-WORD-begin #'evil-forward-WORD-begin
 :scope 'line)

;;;###autoload (autoload 'holymotion-motion-forward-word-end "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-forward-word-end #'evil-forward-word-end
 :scope 'line)

;;;###autoload (autoload 'holymotion-motion-forward-WORD-end "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-forward-WORD-end #'evil-forward-WORD-end
 :scope 'line)

;;;###autoload (autoload 'holymotion-motion-backward-word-begin "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-backward-word-begin #'evil-backward-word-begin
 :scope 'line)

;;;###autoload (autoload 'holymotion-motion-backward-WORD-begin "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-backward-WORD-begin #'evil-backward-WORD-begin
 :scope 'line)

;;;###autoload (autoload 'holymotion-motion-backward-word-end "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-backward-word-end #'evil-backward-word-end
 :scope 'line)

;;;###autoload (autoload 'holymotion-motion-backward-WORD-end "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-backward-WORD-end #'evil-backward-WORD-end
 :scope 'line)

;;;###autoload (autoload 'holymotion-motion-next-line "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-next-line #'next-line
 :pre-hook (setq evil-this-type 'line)
 :bind ((temporary-goal-column (current-column))
        (line-move-visual nil)))

;;;###autoload (autoload 'holymotion-motion-previous-line "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-previous-line #'previous-line
 :pre-hook (setq evil-this-type 'line)
 :bind ((temporary-goal-column (current-column))
        (line-move-visual nil)))

;;;###autoload (autoload 'holymotion-motion-next-visual-line "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-next-visual-line #'next-line
 :pre-hook (setq evil-this-type 'line)
 :bind ((temporary-goal-column (current-column))
        (line-move-visual t)))

;;;###autoload (autoload 'holymotion-motion-previous-visual-line "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-previous-visual-line #'previous-line
 :pre-hook (setq evil-this-type 'line)
 :bind ((temporary-goal-column (current-column))
        (line-move-visual t)))

;;;###autoload (autoload 'holymotion-motion-find-char-to "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-find-char-to #'evil-repeat-find-char
 :pre-hook (save-excursion
             (setq evil-this-type 'inclusive)
             (call-interactively #'evil-find-char-to))
 :bind ((evil-cross-lines t)))

;;;###autoload (autoload 'holymotion-motion-find-char-to-backward "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-find-char-to-backward #'evil-repeat-find-char
 :pre-hook (save-excursion
             (setq evil-this-type 'exclusive)
             (call-interactively #'evil-find-char-to-backward))
 :bind ((evil-cross-lines t)))

;;;###autoload (autoload 'holymotion-motion-find-char "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-find-char #'evil-repeat-find-char
 :pre-hook (save-excursion
             (setq evil-this-type 'inclusive)
             (call-interactively #'evil-find-char))
 :bind ((evil-cross-lines t)))

;;;###autoload (autoload 'holymotion-motion-find-char-backward "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-find-char-backward #'evil-repeat-find-char
 :pre-hook (save-excursion
             (setq evil-this-type 'exclusive)
             (call-interactively #'evil-find-char-backward))
 :bind ((evil-cross-lines t)))

;;;###autoload (autoload 'holymotion-motion-backward-section-begin "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-backward-section-begin #'evil-backward-section-begin
 :pre-hook (setq evil-this-type 'line))

;;;###autoload (autoload 'holymotion-motion-backward-section-end "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-backward-section-end #'evil-backward-section-end
 :pre-hook (setq evil-this-type 'line))

;;;###autoload (autoload 'holymotion-motion-forward-section-begin "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-forward-section-begin #'evil-forward-section-begin
 :pre-hook (setq evil-this-type 'line))

;;;###autoload (autoload 'holymotion-motion-forward-section-end "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-forward-section-end #'evil-forward-section-end
 :pre-hook (setq evil-this-type 'line))

;;;###autoload (autoload 'holymotion-motion-backward-sentence-begin "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-backward-sentence-begin #'evil-backward-sentence-begin)

;;;###autoload (autoload 'holymotion-motion-forward-sentence-begin "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-forward-sentence-begin #'evil-forward-sentence-begin)

;;;###autoload (autoload 'holymotion-motion-search-next "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-search-next #'evil-search-next
 :bind (((symbol-function #'isearch-lazy-highlight-update)
         #'ignore)
        (search-highlight nil)))

;;;###autoload (autoload 'holymotion-motion-search-previous "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-search-previous #'evil-search-previous
 :bind (((symbol-function #'isearch-lazy-highlight-update)
         #'ignore)
        (search-highlight nil)))

;;;###autoload (autoload 'holymotion-motion-search-word-forward "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-search-word-forward #'evil-search-word-forward
 :bind (((symbol-function #'isearch-lazy-highlight-update)
         #'ignore)
        (search-highlight nil)))

;;;###autoload (autoload 'holymotion-motion-search-word-backward "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-search-word-backward #'evil-search-word-backward
 :bind (((symbol-function #'isearch-lazy-highlight-update)
         #'ignore)
        (search-highlight nil)))

;;;###autoload (autoload 'holymotion-motion-previous-line-first-non-blank "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-previous-line-first-non-blank #'evil-previous-line-first-non-blank)

;;;###autoload (autoload 'holymotion-motion-next-line-first-non-blank "holymotion" nil t)
(holymotion-make-motion
 holymotion-motion-next-line-first-non-blank #'evil-next-line-first-non-blank)

;;;###autoload
(defun holymotion-default-keybindings (prefix)
  "Define easymotions for all motions evil defines by default"
  (define-key evil-motion-state-map (kbd prefix) holymotion-map))

(define-key holymotion-map "w" #'holymotion-motion-forward-word-begin)
(define-key holymotion-map "W" #'holymotion-motion-forward-WORD-begin)
(define-key holymotion-map "e" #'holymotion-motion-forward-word-end)
(define-key holymotion-map "E" #'holymotion-motion-forward-WORD-end)
(define-key holymotion-map "b" #'holymotion-motion-backward-word-begin)
(define-key holymotion-map "B" #'holymotion-motion-backward-WORD-begin)
(define-key holymotion-map "ge" #'holymotion-motion-backward-word-end)
(define-key holymotion-map "gE" #'holymotion-motion-backward-WORD-end)
(define-key holymotion-map "j" #'holymotion-motion-next-line)
(define-key holymotion-map "k" #'holymotion-motion-previous-line)
(define-key holymotion-map "gj" #'holymotion-motion-next-visual-line)
(define-key holymotion-map "gk" #'holymotion-motion-previous-visual-line)
(define-key holymotion-map "t" #'holymotion-motion-find-char-to)
(define-key holymotion-map "T" #'holymotion-motion-find-char-to-backward)
(define-key holymotion-map "f" #'holymotion-motion-find-char)
(define-key holymotion-map "F" #'holymotion-motion-find-char-backward)
(define-key holymotion-map "[[" #'holymotion-motion-backward-section-begin)
(define-key holymotion-map "[]" #'holymotion-motion-backward-section-end)
(define-key holymotion-map "]]" #'holymotion-motion-forward-section-begin)
(define-key holymotion-map "][" #'holymotion-motion-forward-section-end)
(define-key holymotion-map "(" #'holymotion-motion-backward-sentence-begin)
(define-key holymotion-map ")" #'holymotion-motion-forward-sentence-begin)
(define-key holymotion-map "n" #'holymotion-motion-search-next)
(define-key holymotion-map "N" #'holymotion-motion-search-previous)
(define-key holymotion-map "*" #'holymotion-motion-search-word-forward)
(define-key holymotion-map "#" #'holymotion-motion-search-word-backward)
(define-key holymotion-map "-" #'holymotion-motion-previous-line-first-non-blank)
(define-key holymotion-map "+" #'holymotion-motion-next-line-first-non-blank)

(provide 'holymotion)
;;; holymotion.el ends here
